SYSTEM CONTEXT

You are assisting in the development of CyberForge-26, an industry-aligned, AI-assisted, multi-agent firmware code generation platform. This project is not a demo, not a toy, and not a single firmware application. It is a framework designed to automatically generate embedded C/C++ firmware, unit tests, quality reports, and OTA-ready deployment artifacts for any microcontroller class, based on structured requirements.

The system is designed with real-world industrial constraints in mind, including safety, auditability, determinism, modularity, and lifecycle traceability. All code generated in this repository must respect these principles.

PROJECT GOAL (NON-NEGOTIABLE)

The goal of CyberForge-26 is to build a governed AI system, not just use AI.

This system must:

Decompose firmware generation into multiple specialized AI agents

Enforce strict governance over those agents using a Model Control Protocol (MCP)

Produce verifiable, auditable artifacts

Remain MCU-agnostic, with hardware-specific logic abstracted

Support secure OTA firmware updates

Follow industry-aligned embedded software practices

Any code that violates these goals is considered incorrect, even if it “works”.

WHAT THIS PROJECT IS NOT

CyberForge-26 is NOT:

A single ESP32 or Arduino firmware project

A UI-focused application

A monolithic AI script

A ChatGPT wrapper

A one-shot prompt-based generator

If you generate code that looks like:

“Call OpenAI once and dump code”

“Hardcode ESP32 logic everywhere”

“Skip governance for speed”

That code is wrong.

HIGH-LEVEL SYSTEM ARCHITECTURE

CyberForge-26 is structured as a layered system:

Interface Layer

Orchestration Layer

AI Agent Layer

Governance & Knowledge Layer

Execution & Integration Layer

Artifact & Audit Layer

Each layer has a clear responsibility boundary.
Cross-layer shortcuts are forbidden.

INTERFACE LAYER

The Interface Layer is responsible only for accepting structured input and triggering execution.

Key characteristics:

CLI-first

Automation-friendly

No business logic

No AI logic

Inputs are provided as JSON or YAML, describing:

System ID

Module list

Module responsibilities

Constraints (memory, safety, coding rules)

OTA requirements

Copilot must never embed logic in the CLI beyond input parsing and invocation.

ORCHESTRATION LAYER (CRITICAL)

The Orchestration Layer is the brain of the system.

Responsibilities:

Execute agents in a deterministic order

Enforce dependencies using a DAG (Directed Acyclic Graph)

Handle retries, failures, and aborts

Never allow agents to self-schedule

Important rules:

Architecture Agent MUST run before Code Agents

Code Agents MUST finish before Test Agent

Quality Agent MUST approve before Build/OTA Agent

Any failure MUST halt or roll back the pipeline

Copilot must generate orchestration code that is:

Explicit

Readable

Deterministic

Logged

AI AGENT MODEL (CORE CONCEPT)

CyberForge-26 uses multiple specialized AI agents, each mirroring a real engineering role.

Required Agents

Requirement Interpreter Agent

Architecture Agent

Code Generation Agent(s) (one per module)

Test Generation Agent

Quality & Safety Agent

Build & OTA Agent

Each agent:

Has one responsibility

Cannot exceed its authority

Operates only via defined inputs and outputs

Agents are not allowed to:

Modify artifacts they do not own

Bypass governance checks

Call other agents directly

Copilot must always treat agents as isolated components, never as shared logic.

MODEL CONTROL PROTOCOL (MCP) – GOVERNANCE LAYER

MCP is a mandatory enforcement layer.

MCP Responsibilities

Role-based access control for agents

Permission checks before every action

Blocking unauthorized artifact access

Logging all decisions and violations

MCP Rules (Examples)

Code Agent cannot modify architecture definitions

Test Agent cannot modify production code

Build Agent cannot change source files

No agent can override MCP decisions

Copilot must never generate code that allows:

Direct file writes without MCP checks

Agents modifying arbitrary files

Silent failures or ignored violations

All agent actions must go through MCP authorization.

RETRIEVAL-AUGMENTED GENERATION (RAG)

AI agents must never generate embedded code without grounding.

RAG is used to:

Inject embedded C/C++ rules

Enforce MISRA/CERT-like constraints

Provide OTA best practices

Prevent hallucinated APIs or unsafe constructs

RAG workflow:

Analyze module type and constraints

Retrieve relevant documents

Rank and filter content

Inject context into prompts

Enforce context size limits

Copilot must assume:

RAG exists as a first-class subsystem

Prompts are composed, not hardcoded

Context injection is explicit

PROMPT MANAGEMENT (VERY IMPORTANT)

Prompts are artifacts, not strings.

Rules:

Prompts are versioned

Prompts are immutable during execution

Each agent has its own prompt template

Prompts explicitly state constraints

Prompt composition stages:

Base system context

Agent role definition

Module responsibility

Constraints and standards

RAG context

MCP rules

Copilot must never inline large prompt strings inside agent logic.

EMBEDDED CODING STANDARDS ALIGNMENT

All generated firmware code must follow embedded-safe practices:

Avoid dynamic memory unless explicitly allowed

Avoid recursion unless justified

Prefer deterministic control flow

Explicit error handling

No undefined behavior

Standards alignment (conceptual, not certified):

MISRA C / C++

CERT C / C++

AUTOSAR-style modularity

IEC 62304-inspired traceability

Copilot should generate defensive, boring, readable code — not clever code.

OTA FIRMWARE UPDATE SUPPORT

OTA is a core feature, not an add-on.

OTA responsibilities:

Firmware image packaging

Version metadata

Integrity checks (hash/signing hooks)

Rollback readiness

OTA logic must be:

Abstracted

Toolchain-agnostic

Logged

Copilot must not hardcode vendor-specific OTA flows unless explicitly requested.

EXECUTION & BUILD LAYER

This layer proves that the system is real.

Responsibilities:

Invoke external toolchains

Capture build logs

Store artifacts

Never silently ignore failures

Build systems are pluggable:

Arduino CLI

ESP-IDF

Generic GCC-based flows

Copilot must generate code that:

Calls tools via subprocesses

Captures stdout/stderr

Fails loudly on errors

ARTIFACT & AUDIT REQUIREMENTS

Every output must be traceable.

Artifacts include:

Source code

Unit tests

Build logs

Quality reports

OTA images

MCP audit logs

Each artifact must include metadata:

Requirement ID

Agent ID

Prompt version

Timestamp

Copilot must never generate “anonymous” outputs.

ERROR HANDLING & RECOVERY

Failure is expected and must be designed.

Required strategies:

Retry (where safe)

Abort on unsafe states

Rollback partial artifacts

Preserve logs for analysis

Copilot must generate explicit error paths, not silent fallbacks.

REPOSITORY STRUCTURE (STRICT)

The repository follows a layered structure:

core/ → orchestration, MCP, RAG

agents/ → AI agents only

schemas/ → JSON schemas

prompts/ → prompt templates

rag_docs/ → grounding documents

output/ → generated artifacts

cli.py → entry point

Copilot must respect this structure at all times.

CODE STYLE EXPECTATIONS

Clear function boundaries

No magic globals

Explicit typing where possible

Readability over brevity

Logging over print statements

Deterministic behavior

This is engineering code, not scripting code.

FINAL INSTRUCTION TO COPILOT

When generating code for CyberForge-26, you must:

Think like a firmware systems engineer

Think like a safety reviewer

Think like a DevOps engineer

Treat AI as powerful but dangerous

Prioritize control, traceability, and clarity

If there is ambiguity, choose:

The safer, more explicit, more auditable design.

END OF CONTEXT