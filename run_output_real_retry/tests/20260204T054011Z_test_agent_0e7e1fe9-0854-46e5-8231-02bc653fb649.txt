This response provides the Unit Test Harness and associated deterministic unit tests for the modules defined, adhering to the specified constraints (Determinism, Traceability, Embedded Context). Since the actual source code is not provided, the tests are written against defined hypothetical interfaces based on the module responsibilities.

### Test Harness and Unit Tests

The test harness uses a minimal C-style structure suitable for embedded environments (e.g., utilizing a tool like Unity, though the macros are simplified here for demonstration).

**Traceability Artifact:**
*   **System/Project:** CyberForge-26, example-system-1
*   **Agent Prompt Version:** v1
*   **Test Generation Date:** [Current Date/Timestamp Placeholder - Ensuring Determinism relies on fixed inputs, not the timestamp itself]

---

### 1. Test Harness Definition (`test_harness.h`)

This defines the necessary assertion and structure macros for deterministic testing.

```c
#ifndef TEST_HARNESS_H
#define TEST_HARNESS_H

#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h> // Required for float comparison

// --- Configuration and Mocks ---
#define UART_MAX_PAYLOAD_SIZE 64

// Mock requirement IDs for traceability
#define REQ_SENSOR_INIT         "REQ_SENSOR_001"
#define REQ_SENSOR_FILTER       "REQ_SENSOR_002"
#define REQ_SENSOR_BOUNDS       "REQ_SENSOR_003"
#define REQ_COMM_FORMAT         "REQ_COMM_001"
#define REQ_COMM_SEND_SUCCESS   "REQ_COMM_002"
#define REQ_COMM_SEND_FAIL      "REQ_COMM_003"

// Global Counters
static int tests_run = 0;
static int tests_failed = 0;

// Test Logging Macros
#define TEST_PASS() \
    printf("[PASS] %s (REQ: %s)\n", __func__, req_id); \
    tests_run++;

#define TEST_FAIL(msg) \
    printf("[FAIL] %s (REQ: %s) L%d: %s\n", __func__, req_id, __LINE__, msg); \
    tests_run++; \
    tests_failed++;

// Assertion Macros (Deterministic Checks)

#define ASSERT_TRUE(condition, msg) \
    if (!(condition)) { TEST_FAIL(msg); return; }

#define ASSERT_EQUALS_INT(expected, actual, msg) \
    if ((expected) != (actual)) { \
        char _m[128]; \
        snprintf(_m, 128, "%s (Expected: %d, Actual: %d)", msg, expected, actual); \
        TEST_FAIL(_m); return; \
    }

#define ASSERT_EQUALS_FLOAT(expected, actual, msg) \
    if (fabs((expected) - (actual)) > 0.0001f) { \
        char _m[128]; \
        snprintf(_m, 128, "%s (Expected: %.4f, Actual: %.4f)", msg, (double)expected, (double)actual); \
        TEST_FAIL(_m); return; \
    }

#define ASSERT_EQUALS_MEM(expected, actual, len, msg) \
    if (memcmp(expected, actual, len) != 0) { \
        TEST_FAIL(msg); return; \
    }

// --- Mock Hardware Abstraction Layer (HAL) Interfaces ---

// Mock State Variables (Crucial for Determinism)
static float mock_raw_sensor_value = 0.0f;
static int mock_hal_read_status = 0;
static bool mock_uart_transmit_succeeds = true;
static uint8_t mock_uart_tx_buffer[UART_MAX_PAYLOAD_SIZE];
static size_t mock_uart_tx_len = 0;

// Mock Setup/Teardown Functions
void mock_hal_setup(void) {
    mock_raw_sensor_value = 0.0f;
    mock_hal_read_status = 0;
    mock_uart_transmit_succeeds = true;
    mock_uart_tx_len = 0;
    memset(mock_uart_tx_buffer, 0, UART_MAX_PAYLOAD_SIZE);
}

// Mock HAL Implementation
int hal_read_raw_sensor(float *raw_data) {
    if (raw_data != NULL) {
        *raw_data = mock_raw_sensor_value;
    }
    return mock_hal_read_status;
}

int hal_uart_send(const uint8_t *data, size_t len) {
    if (!mock_uart_transmit_succeeds) {
        return -1; // Simulate failure
    }
    if (len > UART_MAX_PAYLOAD_SIZE) {
        return -1;
    }
    memcpy(mock_uart_tx_buffer, data, len);
    mock_uart_tx_len = len;
    return 0; // Success
}

#endif // TEST_HARNESS_H
```

### 2. Module Interfaces (Hypothetical SUT - System Under Test)

We define the hypothetical interfaces and simple implementations for testing purposes.

#### `sensor.h` (Hypothetical)

```c
#ifndef SENSOR_H
#define SENSOR_H
// Dependencies: hal_read_raw_sensor()
int sensor_init(void);
float sensor_get_filtered_value(void);
#endif
```

#### `sensor.c` (Minimal Implementation for Testing)

```c
#include "test_harness.h" // Includes mock HAL and types

#define FILTER_K 0.5f // Simple low-pass filter coefficient
#define SENSOR_MAX_VALUE 100.0f

static float sensor_state_filtered_value = 0.0f;

int sensor_init(void) {
    sensor_state_filtered_value = 0.0f;
    return 0;
}

// Responsibility: 'read sensor and provide filtered value'
float sensor_get_filtered_value(void) {
    float raw_val;

    if (hal_read_raw_sensor(&raw_val) != 0) {
        // Handle read error by returning last known state or 0.0f
        return sensor_state_filtered_value;
    }

    // 1. Filtering (Simple LPF)
    sensor_state_filtered_value = (raw_val * FILTER_K) + (sensor_state_filtered_value * (1.0f - FILTER_K));

    // 2. Boundary Check/Clipping (Ensuring RAG guidelines for robust systems)
    if (sensor_state_filtered_value > SENSOR_MAX_VALUE) {
        sensor_state_filtered_value = SENSOR_MAX_VALUE;
    }
    if (sensor_state_filtered_value < 0.0f) {
        sensor_state_filtered_value = 0.0f;
    }

    return sensor_state_filtered_value;
}
```

#### `comm.h` (Hypothetical)

```c
#ifndef COMM_H
#define COMM_H
// Dependencies: hal_uart_send()
int comm_init(void);
int comm_send_telemetry(float sensor_value, uint32_t timestamp);
#endif
```

#### `comm.c` (Minimal Implementation for Testing)

```c
#include "test_harness.h"

// Telemetry Packet Structure (Example)
typedef struct {
    uint8_t header;     // 0xA5
    uint32_t timestamp;
    float value;
    uint16_t checksum; // Simple XOR checksum
} telemetry_packet_t;

static uint16_t calculate_checksum(const void *data, size_t len) {
    const uint8_t *bytes = (const uint8_t *)data;
    uint16_t crc = 0;
    for (size_t i = 0; i < len; i++) {
        crc ^= bytes[i];
    }
    return crc;
}

int comm_init(void) {
    return 0;
}

// Responsibility: 'send telemetry over UART'
int comm_send_telemetry(float sensor_value, uint32_t timestamp) {
    telemetry_packet_t packet;
    size_t payload_len = sizeof(telemetry_packet_t);
    
    if (payload_len > UART_MAX_PAYLOAD_SIZE) {
        return -2; // Should not happen if sizes are fixed
    }

    packet.header = 0xA5;
    packet.timestamp = timestamp;
    packet.value = sensor_value;
    
    // Calculate checksum over header, timestamp, and value fields
    packet.checksum = calculate_checksum(&packet, payload_len - sizeof(uint16_t));
    
    // Send using the HAL
    return hal_uart_send((const uint8_t *)&packet, payload_len);
}
```

### 3. Unit Tests (`unit_tests.c`)

```c
#include "test_harness.h"
#include "sensor.h"
#include "comm.h"

// --- Sensor Module Tests ---

void test_sensor_01_init(const char *req_id) {
    // 1. Setup
    mock_hal_setup();
    
    // 2. Action
    int result = sensor_init();
    
    // 3. Assert
    ASSERT_EQUALS_INT(0, result, "Initialization must return success code 0.");
    ASSERT_EQUALS_FLOAT(0.0f, sensor_get_filtered_value(), "Filtered value must reset to 0.0 on init.");
    
    TEST_PASS();
}

void test_sensor_02_nominal_filtering(const char *req_id) {
    // Tests deterministic filtering behavior
    // 1. Setup
    mock_hal_setup();
    sensor_init();
    
    // Cycle 1: Input 10.0. Filtered = 0.5*10.0 + 0.5*0.0 = 5.0
    mock_raw_sensor_value = 10.0f;
    float filtered1 = sensor_get_filtered_value();
    ASSERT_EQUALS_FLOAT(5.0f, filtered1, "Cycle 1 filter calculation incorrect.");

    // Cycle 2: Input 20.0. Filtered = 0.5*20.0 + 0.5*5.0 = 12.5
    mock_raw_sensor_value = 20.0f;
    float filtered2 = sensor_get_filtered_value();
    ASSERT_EQUALS_FLOAT(12.5f, filtered2, "Cycle 2 filter calculation incorrect.");
    
    TEST_PASS();
}

void test_sensor_03_data_clipping(const char *req_id) {
    // Tests boundary handling as per robust design (MISRA/CERT recommendation)
    // 1. Setup
    mock_hal_setup();
    sensor_init();

    // 2. Action: Force a reading far above the defined SENSOR_MAX_VALUE (100.0f)
    mock_raw_sensor_value = 500.0f; 
    
    // First cycle (Filter input: 500.0f, State: 0.0f) -> Filtered output: 250.0f
    // Since 250.0f > 100.0f (SENSOR_MAX_VALUE), it should clip.
    float clipped_val = sensor_get_filtered_value();

    // 3. Assert
    ASSERT_EQUALS_FLOAT(100.0f, clipped_val, "Value must be clipped to SENSOR_MAX_VALUE.");

    // Ensure subsequent readings are based on the clipped value (100.0f)
    mock_raw_sensor_value = 0.0f; 
    // Second cycle (Filter input: 0.0f, State: 100.0f) -> Filtered output: 0.5*0 + 0.5*100 = 50.0f
    float decay_val = sensor_get_filtered_value();
    ASSERT_EQUALS_FLOAT(50.0f, decay_val, "Subsequent state must use the clipped value for stability.");

    TEST_PASS();
}

void test_sensor_04_read_failure(const char *req_id) {
    // Tests handling of HAL read failure
    // 1. Setup
    mock_hal_setup();
    sensor_init();
    
    // Prime the filter state (e.g., to 50.0f)
    mock_raw_sensor_value = 100.0f; 
    sensor_get_filtered_value(); // State is now 50.0f

    // 2. Action: Simulate HAL failure
    mock_hal_read_status = -1; 
    float failed_read_val = sensor_get_filtered_value();

    // 3. Assert: Must return the last good value (50.0f) without updating state
    ASSERT_EQUALS_FLOAT(50.0f, failed_read_val, "Read failure must result in returning the last known good value.");
    
    TEST_PASS();
}

// --- Communication Module Tests ---

void test_comm_01_payload_format_and_checksum(const char *req_id) {
    // 1. Setup
    mock_hal_setup();
    uint32_t test_ts = 0xDEADBEEF;
    float test_val = 12.34f; // IEEE 754 representation needed for deterministic checking
    
    // For deterministic testing, we need the exact byte representation of 12.34f
    // 12.34f is typically 0x414570A4 (assuming standard little-endian float representation)
    
    // Expected raw bytes (4+4+4+2 = 14 bytes total)
    // Header (1 byte): 0xA5
    // Timestamp (4 bytes, little endian assumed): EF BE AD DE
    // Value (4 bytes, little endian assumed: 12.34f -> 0xA4 70 45 41
    // Checksum (2 bytes placeholder)
    
    // Checksum calculation on: 0xA5 + EF + BE + AD + DE + A4 + 70 + 45 + 41 = 0x05 (XOR Sum)
    
    uint8_t expected_payload[] = {
        0xA5,                               // Header
        0xEF, 0xBE, 0xAD, 0xDE,             // Timestamp (0xDEADBEEF)
        0xA4, 0x70, 0x45, 0x41,             // Value (12.34f)
        0x05, 0x00                          // Checksum (0x05 XOR, 0x00 padding/second byte)
    };
    size_t expected_len = sizeof(expected_payload);

    // 2. Action
    int result = comm_send_telemetry(test_val, test_ts);

    // 3. Assert
    ASSERT_EQUALS_INT(0, result, "Telemetry transmission must succeed.");
    ASSERT_EQUALS_INT(expected_len, mock_uart_tx_len, "Payload length must match expected structure size.");
    ASSERT_EQUALS_MEM(expected_payload, mock_uart_tx_buffer, expected_len, "Transmitted payload does not match expected format or checksum calculation.");
    
    TEST_PASS();
}

void test_comm_02_transmission_failure(const char *req_id) {
    // 1. Setup
    mock_hal_setup();
    mock_uart_transmit_succeeds = false; // Force the HAL layer to fail
    
    // 2. Action
    int result = comm_send_telemetry(1.0f, 100);

    // 3. Assert
    ASSERT_EQUALS_INT(-1, result, "Comm module must report failure when HAL transmission fails.");
    ASSERT_EQUALS_INT(0, mock_uart_tx_len, "No data should be considered transmitted upon failure.");

    TEST_PASS();
}


// --- Main Test Runner ---

int main(void) {
    printf("--- CyberForge-26 Unit Tests (Traceability: Prompt v1) ---\n");
    printf("--- Testing SENSOR Module ---\n");
    test_sensor_01_init(REQ_SENSOR_INIT);
    test_sensor_02_nominal_filtering(REQ_SENSOR_FILTER);
    test_sensor_03_data_clipping(REQ_SENSOR_BOUNDS);
    test_sensor_04_read_failure(REQ_SENSOR_FILTER); // Testing robust filtering behavior
    
    printf("\n--- Testing COMM Module ---\n");
    test_comm_01_payload_format_and_checksum(REQ_COMM_FORMAT); // Covers REQ_COMM_SEND_SUCCESS indirectly
    test_comm_02_transmission_failure(REQ_COMM_SEND_FAIL);

    printf("\n--- Test Summary ---\n");
    printf("Total Tests Run: %d\n", tests_run);
    if (tests_failed == 0) {
        printf("Result: ALL TESTS PASSED (%d failures).\n", tests_failed);
        return 0;
    } else {
        printf("Result: FAILURES DETECTED (%d failures).\n", tests_failed);
        return -1;
    }
}
```

### Traceability Summary

| Test Function | Module | Responsibility/Feature Tested | Requirement ID | Determinism Basis |
| :--- | :--- | :--- | :--- | :--- |
| `test_sensor_01_init` | `sensor` | Initialization/State Reset | `REQ_SENSOR_001` | Fixed return code (0), fixed state variable reset. |
| `test_sensor_02_nominal_filtering` | `sensor` | Filtering (LPF calculation) | `REQ_SENSOR_002` | Fixed filter constant (0.5), fixed mock raw inputs (10.0, 20.0). |
| `test_sensor_03_data_clipping` | `sensor` | Handling Out-of-Range Inputs | `REQ_SENSOR_003` | Fixed upper boundary (100.0f), fixed mock raw input (500.0f). |
| `test_sensor_04_read_failure` | `sensor` | Robustness during HAL failure | `REQ_SENSOR_002` | Mock status flag forces deterministic failure (-1). |
| `test_comm_01_payload_format_and_checksum`| `comm` | Telemetry Format & Checksum | `REQ_COMM_001` | Fixed input values (12.34f, 0xDEADBEEF), deterministic checksum algorithm (XOR). |
| `test_comm_02_transmission_failure` | `comm` | Handling UART driver failure | `REQ_COMM_003` | Mock status flag forces deterministic HAL failure. |