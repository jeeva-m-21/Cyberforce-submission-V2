### Artifact Metadata
*   Requirement ID: REQ\_COMM\_001
*   Agent ID: code\_agent\_v1
*   Prompt Version: v1

The following files implement the `comm` module responsible for sending telemetry over UART, adhering to embedded constraints (no dynamic memory, deterministic structure) and safety guidelines (MISRA/CERT principles applied where applicable).

---

## `comm.h`

```c
#ifndef COMM_H
#define COMM_H

#include <stdint.h>
#include <stddef.h>

// Artifact Metadata:
// Requirement ID: REQ_COMM_001
// Agent ID: code_agent_v1
// Prompt Version: v1

/**
 * @brief Telemetry Structure Definition for transmission.
 * 
 * Note: Use fixed-width types to ensure deterministic sizing and serialization.
 */
typedef struct {
    uint32_t timestamp_ms;  /**< System uptime in milliseconds */
    uint16_t sensor_id;     /**< Identifier for the source sensor */
    int16_t value_a;        /**< Primary measured value (signed) */
    uint8_t status_flags;   /**< Status flags or error codes */
} telemetry_packet_t;

/**
 * @brief Initializes the communication module and configures the UART hardware.
 * 
 * @return 0 on success, non-zero error code otherwise.
 */
int comm_init(void);

/**
 * @brief Sends a telemetry packet over the configured UART interface.
 * 
 * The implementation handles serialization of the packet structure into 
 * a byte stream for transmission.
 * 
 * @param packet Pointer to the telemetry packet to send. Must not be NULL.
 * @return size_t The number of bytes successfully queued or written, 0 on failure.
 */
size_t comm_send_telemetry(const telemetry_packet_t *packet);

#endif // COMM_H
```

---

## `comm.c`

```c
#include "comm.h"

#include <string.h> // Required for deterministic buffer copying (memcpy)

// --- Artifact Metadata ---
// Requirement ID: REQ_COMM_001
// Agent ID: code_agent_v1
// Prompt Version: v1
// Constraints: No dynamic memory used. Deterministic structure.
// -------------------------

// Configuration Constants 
// These should ideally be defined in a dedicated configuration file.
#define COMM_UART_BAUD_RATE     (115200U)
#define COMM_MAX_PACKET_SIZE    (sizeof(telemetry_packet_t)) 
#define COMM_TX_ERROR           (0)

// --- Hardware Abstraction Layer (HAL) Mock ---
// In a real system, these would interface with peripheral registers.

/**
 * @brief Mock function to initialize the UART hardware based on baud rate.
 */
static void hal_uart_configure(uint32_t baud)
{
    // Implementation: Set clock sources, enable peripheral, configure pins.
    (void)baud; 
}

/**
 * @brief Low-level function to write a single byte to the UART transmission buffer.
 * 
 * @param byte The byte to transmit.
 * @return int 0 on success, -1 if transmission failed (e.g., timeout, buffer full).
 */
static int uart_write_byte(uint8_t byte)
{
    // Implementation: Wait for TX buffer empty, write 'byte'.
    // For demonstration, always return success.
    (void)byte; 
    return 0;
}

// --- Module Implementation ---

/**
 * @brief Initialize the communication module (UART setup).
 * 
 * Implements the external function from comm.h
 */
int comm_init(void)
{
    // MISRA/CERT Guideline: Ensure all required setup steps are completed before use.
    hal_uart_configure(COMM_UART_BAUD_RATE);
    
    return 0;
}

/**
 * @brief Serializes the packet structure into a byte buffer and transmits it.
 * 
 * This uses a deterministic, stack-allocated buffer for serialization, 
 * avoiding dynamic memory usage.
 * 
 * @param packet The validated pointer to the data structure.
 * @return size_t The number of bytes transmitted.
 */
static size_t comm_serialize_and_send(const telemetry_packet_t *packet)
{
    // Fixed size buffer on the stack. Safe since packet size is known and small.
    uint8_t tx_buffer[COMM_MAX_PACKET_SIZE];
    const size_t size_to_send = sizeof(telemetry_packet_t);
    size_t bytes_written = 0;
    
    // CERT Rule DCL03-C: Avoid type punning. Use memcpy for safe structure copy.
    // Copies the structure data into the byte array for sequential transmission.
    (void)memcpy(tx_buffer, packet, size_to_send);

    // Transmit every byte sequentially
    for (size_t i = 0; i < size_to_send; ++i)
    {
        if (uart_write_byte(tx_buffer[i]) == 0)
        {
            bytes_written++;
        }
        else
        {
            // Transmission failure/error handling (e.g., logging)
            break; 
        }
    }

    return bytes_written;
}


/**
 * @brief Sends a telemetry packet over UART.
 * 
 * Implements the external function from comm.h
 */
size_t comm_send_telemetry(const telemetry_packet_t *packet)
{
    // CERT EXP34-C: Check for NULL pointers before dereferencing.
    if (packet == NULL)
    {
        return COMM_TX_ERROR;
    }

    return comm_serialize_and_send(packet);
}
```